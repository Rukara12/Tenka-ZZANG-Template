<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>텐카 템플릿</title>
    <style>
        /* [1] 웹폰트 정의 */
        @font-face {
            font-family: 'PyeongtaekSunset';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408@1.0/PTNoeulL.woff2') format('woff2');
            font-weight: 300;
            font-display: swap;
        }

        @font-face {
            font-family: 'PyeongtaekSunset';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408@1.0/PTNoeulB.woff2') format('woff2');
            font-weight: 700;
            font-display: swap;
        }

        /* [2] 기본 스타일 */
        body { 
            margin: 0; padding: 0; 
            touch-action: manipulation; 
            font-family: 'PyeongtaekSunset', sans-serif; 
            overflow-x: hidden;
            width: 100%;
        }

        #meme-container {
            position: relative;
            width: 1024px;
            height: 765px;
            margin: 20px auto;
            border: 2px solid #333;
            overflow: hidden;
            background-color: #f0f0f0;
            user-select: none;
            touch-action: none;
            transform-origin: top center;
        }

        @media screen and (max-width: 1024px) {
            #meme-container {
                transform: scale(calc(100vw / 1060));
                margin-bottom: calc(765px * (calc(100vw / 1060) - 1) + 20px);
            }
        }

        /* 사진 레이어 수정 */
        .photo-layer {
            position: absolute;
            overflow: hidden;
            transition: opacity 0.2s; /* 부드러운 전환을 위해 추가 */
        }

        /* 말풍선 사진: 중앙 말풍선 영역 */
        #layer-photo-1 { 
            z-index: 1; 
            top: 0px; 
            left: 200px; 
            width: 700px; 
            height: 440px; 
        }
        
        /* 핸드폰 사진: 핸드폰 화면 영역 */
        #layer-photo-2 { 
            z-index: 2; 
            top: 470px; 
            left: 531px; 
            width: 90px; 
            height: 150px; 
        }

        .preview-image {
            position: absolute;
            top: 0; left: 0; 
            width: 100%; height: auto;
            display: none; cursor: move;
            transform-origin: center;
        }

        #background-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: url('tenka.png'); 
            background-size: 100% 100%;
            z-index: 3;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        /* [3] 말풍선 스타일 */
        .bubble {
            position: absolute;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-family: 'PyeongtaekSunset', sans-serif;
            font-weight: 700;
            line-height: 1.2;
            z-index: 4;
            outline: none;
            white-space: pre-wrap;
            word-break: break-word;
            padding: 15px;
            box-sizing: border-box;
            overflow: hidden;
            color: #000;
            transition: opacity 0.2s; /* 부드러운 전환을 위해 추가 */
        }

        #bubble-top-left { top: 1px; left: 1px; width: 215px; height: 330px; }
        #bubble-bottom-left { top: 420px; left: 1px; width: 230px; height: 350px; }
        #bubble-top-right { top: 1px; left: 810px; width: 215px; height: 410px; }

        #controls { text-align: center; padding: 20px; background: #eee; border-bottom: 1px solid #ccc; font-family: sans-serif; }
        .btn-group { margin-bottom: 10px; }
        button { padding: 10px 20px; font-size: 15px; cursor: pointer; border-radius: 4px; border: 1px solid #999; font-weight: bold; }
        .save-btn { background: #28a745; color: white; border: none; }
        .upload-btn { background: #007bff; color: white; border: none; margin: 5px; }
        .font-btn { background: #6c757d; color: white; border: none; margin: 5px; }
        .selector { margin: 10px; font-weight: bold; font-size: 16px; padding: 10px; background: #fff; display: inline-block; border-radius: 8px; border: 1px solid #ddd; }
        .hint { color: #666; font-size: 13px; margin-top: 5px; }
    </style>
</head>
<body>

<div id="controls">
    <div class="btn-group">
        <button class="upload-btn" onclick="document.getElementById('img-input-1').click();">말풍선 사진</button>
        <button class="upload-btn" onclick="document.getElementById('img-input-2').click();">핸드폰 사진</button>
        <button class="font-btn" onclick="document.getElementById('font-input').click();">다른 폰트로 변경</button>
        <button class="save-btn" id="save-btn">이미지 저장</button>
    </div>

    <div class="selector">
        조작 대상: 
        <label style="cursor:pointer"><input type="radio" name="target" value="none" checked> 없음</label>
        &nbsp;
        <label style="cursor:pointer"><input type="radio" name="target" value="1"> 말풍선 사진</label>
        &nbsp;
        <label style="cursor:pointer"><input type="radio" name="target" value="2"> 핸드폰 사진</label>
    </div>
    
    <div class="hint">기본 폰트는 '평택 노을체'입니다. 텍스트는 'Enter'로 줄바꿈이 가능하니 적절히 조절하세요.</div>
    <div class="hint">사진은 조작 대상 선택 후 드래그/휠/핀치 줌으로 조작하세요.</div>

    <input type="file" id="img-input-1" accept="image/*" style="display:none">
    <input type="file" id="img-input-2" accept="image/*" style="display:none">
    <input type="file" id="font-input" accept=".ttf, .otf, .woff, .woff2" style="display:none">
</div>

<div id="meme-container">
    <div id="layer-photo-1" class="photo-layer"><img id="img-1" class="preview-image" draggable="false"></div>
    <div id="layer-photo-2" class="photo-layer"><img id="img-2" class="preview-image" draggable="false"></div>
    <div id="background-layer"></div>

    <div id="bubble-top-left" class="bubble" contenteditable="true" spellcheck="false">텐카쨩 반박하는 내용··· 듣기 싫은 말···</div>
    <div id="bubble-bottom-left" class="bubble" contenteditable="true" spellcheck="false">나쨩 미안··· 잘 안 들려··· 아무튼 어쩌구 저쩌구 한데다 이러저러하고 이래저래 장점이 많아서 재밌는 게임이라는 장황한 설명···</div>
    <div id="bubble-top-right" class="bubble" contenteditable="true" spellcheck="false">나쨩 이거 봐봐···! 대충 어쩌구 저쩌구 갓겜···!</div>
</div>

<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
<script>
    const maxFontSize = 42;
    const minFontSize = 12;

    function adjustFontSize(el) {
        let fontSize = maxFontSize;
        el.style.fontSize = fontSize + 'px';
        while ((el.scrollHeight > el.offsetHeight || el.scrollWidth > el.offsetWidth) && fontSize > minFontSize) {
            fontSize--;
            el.style.fontSize = fontSize + 'px';
        }
    }

    window.addEventListener('load', () => {
        document.fonts.ready.then(() => {
            document.querySelectorAll('.bubble').forEach(bubble => adjustFontSize(bubble));
        });
        updateVisibility(); // 초기 상태 설정
    });

    document.querySelectorAll('.bubble').forEach(bubble => {
        bubble.addEventListener('input', () => adjustFontSize(bubble));
        bubble.addEventListener('paste', (e) => {
            e.preventDefault();
            const text = e.clipboardData.getData('text/plain');
            document.execCommand('insertText', false, text);
            adjustFontSize(bubble);
        });
    });

    document.getElementById('font-input').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = async (ev) => {
                const fontName = 'UploadedCustomFont';
                const fontFace = new FontFace(fontName, ev.target.result);
                try {
                    const loadedFace = await fontFace.load();
                    document.fonts.add(loadedFace);
                    document.querySelectorAll('.bubble').forEach(bubble => {
                        bubble.style.fontFamily = fontName;
                        adjustFontSize(bubble);
                    });
                    alert('새로운 폰트가 적용되었습니다.');
                } catch (err) {
                    alert('폰트 로드 실패');
                }
            };
            reader.readAsArrayBuffer(file);
        }
    });

    const states = {
        1: { x: 0, y: 0, scale: 1.0, el: document.getElementById('img-1') },
        2: { x: 0, y: 0, scale: 1.0, el: document.getElementById('img-2') }
    };

    let isDragging = false;
    let startX, startY;
    let initialDist = 0;

    function getTargetId() {
        return document.querySelector('input[name="target"]:checked').value;
    }

    /* 조작 대상에 따른 가시성 통합 제어 로직 */
    function updateVisibility() {
        const targetId = getTargetId();
        const bg = document.getElementById('background-layer');
        const p1 = document.getElementById('layer-photo-1');
        const p2 = document.getElementById('layer-photo-2');
        const bubbles = document.querySelectorAll('.bubble');

        if (targetId === '1' || targetId === '2') {
            // 조작 대상이 말풍선 사진 또는 2일 때
            bg.style.opacity = '0.3';
            p1.style.opacity = (targetId === '1' ? '1' : '0');
            p2.style.opacity = (targetId === '2' ? '1' : '0');
            bubbles.forEach(b => b.style.opacity = '0');
        } else {
            // 조작 대상이 '없음'일 때 (모두 100%)
            bg.style.opacity = '1';
            p1.style.opacity = '1';
            p2.style.opacity = '1';
            bubbles.forEach(b => b.style.opacity = '1');
        }
    }

    document.querySelectorAll('input[name="target"]').forEach(radio => {
        radio.addEventListener('change', updateVisibility);
    });

    function updateTransform(id) {
        if (id === 'none') return;
        const s = states[id];
        if (s.el) {
            s.el.style.transform = `translate(${s.x}px, ${s.y}px) scale(${s.scale})`;
        }
    }

    function setupUpload(id) {
        document.getElementById(`img-input-${id}`).addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    states[id].el.src = ev.target.result;
                    states[id].el.style.display = 'block';
                    updateTransform(id);
                };
                reader.readAsDataURL(file);
            }
        });
    }
    setupUpload(1); setupUpload(2);

    const container = document.getElementById('meme-container');

    container.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('bubble')) return;
        const id = getTargetId();
        if (id === 'none' || !states[id].el.src) return;
        isDragging = true;
        startX = e.clientX - states[id].x;
        startY = e.clientY - states[id].y;
    });

    container.addEventListener('touchstart', (e) => {
        if (e.target.classList.contains('bubble')) return;
        const id = getTargetId();
        if (id === 'none' || !states[id].el.src) return;

        if (e.touches.length === 1) {
            isDragging = true;
            startX = e.touches[0].clientX - states[id].x;
            startY = e.touches[0].clientY - states[id].y;
        } else if (e.touches.length === 2) {
            isDragging = false; 
            initialDist = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
        }
    }, { passive: false });

    window.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const id = getTargetId();
        if (id === 'none') return;
        states[id].x = e.clientX - startX;
        states[id].y = e.clientY - startY;
        updateTransform(id);
    });

    window.addEventListener('touchmove', (e) => {
        const id = getTargetId();
        if (id === 'none' || !states[id].el.src) return;

        if (e.touches.length === 1 && isDragging) {
            states[id].x = e.touches[0].clientX - startX;
            states[id].y = e.touches[0].clientY - startY;
            updateTransform(id);
            if (e.cancelable) e.preventDefault();
        } else if (e.touches.length === 2) {
            const currentDist = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            const zoomFactor = currentDist / initialDist;
            states[id].scale *= zoomFactor;
            states[id].scale = Math.max(0.05, Math.min(10, states[id].scale));
            initialDist = currentDist;
            updateTransform(id);
            if (e.cancelable) e.preventDefault();
        }
    }, { passive: false });

    window.addEventListener('mouseup', () => isDragging = false);
    window.addEventListener('touchend', () => { isDragging = false; initialDist = 0; });

    container.addEventListener('wheel', (e) => {
        const id = getTargetId();
        if (id === 'none' || !states[id].el.src) return;
        e.preventDefault();
        const zoomSpeed = 0.05;
        if (e.deltaY < 0) states[id].scale += zoomSpeed;
        else states[id].scale = Math.max(0.05, states[id].scale - zoomSpeed);
        updateTransform(id);
    }, { passive: false });

    document.getElementById('save-btn').addEventListener('click', function() {
        const bg = document.getElementById('background-layer');
        const p1 = document.getElementById('layer-photo-1');
        const p2 = document.getElementById('layer-photo-2');
        const bubbles = document.querySelectorAll('.bubble');

        // 저장 시 모든 레이어를 보이게 설정
        const prevOpacity = { bg: bg.style.opacity, p1: p1.style.opacity, p2: p2.style.opacity };
        bg.style.opacity = '1'; p1.style.opacity = '1'; p2.style.opacity = '1';
        bubbles.forEach(b => b.style.opacity = '1');

        html2canvas(container, { 
            scale: 2, 
            useCORS: true,
            logging: false,
            backgroundColor: null
        }).then(canvas => {
            const link = document.createElement('a');
            link.download = '텐카_결과물.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            // 저장 후 원래 가시성으로 복구
            updateVisibility();
        });
    });
</script>

</body>
</html>
