<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>í…ì¹´ í…œí”Œë¦¿ ì—ë””í„°</title>
    <style>
        /* [1] ì›¹í°íŠ¸ ì •ì˜ */
        @font-face {
            font-family: 'PyeongtaekSunset';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408@1.0/PTNoeulL.woff2') format('woff2');
            font-weight: 300;
            font-display: swap;
        }
        @font-face {
            font-family: 'PyeongtaekSunset';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408@1.0/PTNoeulB.woff2') format('woff2');
            font-weight: 700;
            font-display: swap;
        }

        /* [2] ë ˆì´ì•„ì›ƒ ìŠ¤íƒ€ì¼ */
        body { 
            margin: 0; padding: 0; 
            font-family: 'PyeongtaekSunset', sans-serif; 
            background-color: #e9ecef;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        body.mobile-mode {
            flex-direction: column;
            overflow-y: auto;
            height: auto;
        }

        /* ì‚¬ì´ë“œë°” */
        .sidebar {
            width: 300px;
            background: #ffffff;
            border-right: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.05);
            overflow-y: auto;
            z-index: 10;
        }
        .sidebar.right {
            border-right: none;
            border-left: 1px solid #dee2e6;
        }

        body.mobile-mode .sidebar {
            width: 100%;
            border: none;
            order: 2;
            box-sizing: border-box;
            overflow-y: visible;
        }

        /* ë©”ì¸ ì‘ì—… ì˜ì—­ */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: auto;
            padding: 40px;
            background-color: #ced4da;
            position: relative;
        }

        body.mobile-mode .main-content {
            order: 1;
            padding: 20px 0;
            min-height: 450px;
            display: block;
            text-align: center;
        }

        /* ì»¨íŠ¸ë¡¤ ê·¸ë£¹ ë° ì•„ì½”ë””ì–¸ */
        .control-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #f1f3f5;
        }
        .section-title {
            font-size: 15px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #495057;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }
        .section-content {
            display: block;
        }
        .section-content.collapsed {
            display: none;
        }
        .toggle-arrow {
            font-size: 10px;
            transition: transform 0.2s;
        }

        /* ì´ˆê¸°í™” ë²„íŠ¼ ìŠ¤íƒ€ì¼ ë° ì •ë ¬ */
        .reset-mini-btn {
            background: #f1f3f5;
            border: 1px solid #dee2e6;
            color: #868e96;
            font-size: 11px;
            cursor: pointer;
            padding: 2px 5px;
            margin-left: 8px;
            border-radius: 4px;
            display: inline-flex;
            align-items: center;
            transition: all 0.2s;
            vertical-align: middle;
        }
        .reset-mini-btn:hover { 
            background: #e9ecef;
            color: #dc3545;
            border-color: #dc3545;
        }

        .label-with-reset {
            display: flex;
            align-items: center;
            font-size: 13px;
        }

        /* ìº”ë²„ìŠ¤ ì»¨í…Œì´ë„ˆ */
        .canvas-container-wrapper {
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            background-color: #fff;
            transform-origin: center top;
            transition: transform 0.3s ease;
            display: inline-block;
        }

        /* ë²„íŠ¼ ë° ì…ë ¥ì°½ */
        button:not(.reset-mini-btn) { 
            width: 100%;
            padding: 10px; 
            font-size: 14px; 
            cursor: pointer; 
            border-radius: 6px; 
            border: 1px solid #ced4da; 
            font-weight: bold;
            margin-bottom: 8px;
            transition: all 0.2s;
        }
        button:hover { opacity: 0.8; }
        .save-btn { background: #28a745; color: white; border: none; font-size: 16px; padding: 15px; margin-top: 10px; }
        .upload-btn { background: #007bff; color: white; border: none; }
        .font-btn { background: #6c757d; color: white; border: none; }
        .history-btn { background: #6c757d; color: white; border: none; font-size: 12px; padding: 8px; flex: 1; }
        .issue-btn { background: #ffc107; color: #212529; border: none; margin-bottom: 5px; }

        .selector-box {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        .selector-box label {
            display: block;
            margin: 8px 0;
            cursor: pointer;
            font-size: 14px;
        }

        .hint { color: #868e96; font-size: 12px; margin-top: 5px; line-height: 1.4; }
        
        /* í°íŠ¸ ì»¨íŠ¸ë¡¤ */
        .slider-item { margin: 8px 0; display: flex; align-items: center; justify-content: space-between; font-size: 13px; }
        .slider-item input[type="range"] { width: 90px; }
        .num-input { width: 50px; padding: 4px; border: 1px solid #ced4da; border-radius: 4px; font-size: 12px; text-align: center; }

        /* ë¡œë”© ì˜¤ë²„ë ˆì´ */
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); color: white; z-index: 9999;
            display: none; justify-content: center; align-items: center; flex-direction: column;
        }
        .spinner {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="loading-overlay">
    <div class="spinner"></div>
    <div id="loading-text">ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤...</div>
</div>

<aside class="sidebar">
    <div class="control-section">
        <div class="section-title" onclick="toggleSection(this)">
            <span>ğŸ–¼ï¸ ì´ë¯¸ì§€ ì—…ë¡œë“œ (GIF ì§€ì›)</span>
            <span class="toggle-arrow">â–¼</span>
        </div>
        <div class="section-content">
            <button class="upload-btn" onclick="document.getElementById('img-input-1').click();">ë§í’ì„  ì‚¬ì§„</button>
            <button class="upload-btn" onclick="document.getElementById('img-input-2').click();">í•¸ë“œí° ì‚¬ì§„</button>
            <button class="upload-btn" onclick="document.getElementById('img-input-3').click();">ë¡œê³  ì‚¬ì§„</button>
            <input type="file" id="img-input-1" accept="image/*" style="display:none" onclick="this.value=null">
            <input type="file" id="img-input-2" accept="image/*" style="display:none" onclick="this.value=null">
            <input type="file" id="img-input-3" accept="image/*" style="display:none" onclick="this.value=null">
        </div>
    </div>

    <div class="control-section">
        <div class="section-title" onclick="toggleSection(this)">
            <span>ğŸ•¹ï¸ ì¡°ì‘ ëŒ€ìƒ</span>
            <span class="toggle-arrow">â–¼</span>
        </div>
        <div class="section-content">
            <div class="selector-box">
                <label><input type="radio" name="target" value="none" checked> ì„ íƒ ì—†ìŒ</label>
                <label><input type="radio" name="target" value="img1"> ë§í’ì„  ì‚¬ì§„</label>
                <label><input type="radio" name="target" value="img2"> í•¸ë“œí° ì‚¬ì§„</label>
                <label><input type="radio" name="target" value="img3"> ë¡œê³  ì‚¬ì§„</label>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-top: 10px;">
                    <button onclick="resetActiveObject()" style="font-size: 12px; padding: 5px;">ì´ˆê¸°í™”</button>
                    <button onclick="rotateActiveObject()" style="font-size: 12px; padding: 5px;">íšŒì „</button>
                    <button onclick="flipActiveObject()" style="font-size: 12px; padding: 5px;">ë°˜ì „</button>
                    <button onclick="deleteActiveObject()" style="font-size: 12px; padding: 5px; background: #dc3545; color: white; border: none;">ì‚­ì œ</button>
                </div>
            </div>
        </div>
    </div>

    <div class="control-section">
        <div class="section-title" onclick="toggleSection(this)">
            <span>ğŸ” SteamGridDB ê²€ìƒ‰</span>
            <span class="toggle-arrow">â–¼</span>
        </div>
        <div class="section-content">
            <input type="text" id="sgdb-input" placeholder="ê²Œì„ëª… ì…ë ¥" style="width: 100%; padding: 8px; margin-bottom: 5px; box-sizing: border-box;">
            <button class="upload-btn" id="sgdb-search-btn" style="background:#495057">ê²€ìƒ‰í•˜ê¸°</button>
        </div>
    </div>

    <div class="control-section">
        <div class="section-title" onclick="toggleSection(this)">
            <span>ğŸ“Š ì›€ì§¤ ì •ë³´ (ì¸¡ì •ë¨)</span>
            <span class="toggle-arrow">â–¼</span>
        </div>
        <div class="section-content">
            <div id="detected-fps-info" style="font-size: 13px; color: #495057; line-height: 1.6;">
                ì¸¡ì •ëœ FPS: -
            </div>
        </div>
    </div>
</aside>

<main class="main-content" id="drop-zone">
    <div class="canvas-container-wrapper" id="canvas-wrapper">
        <canvas id="c" width="1024" height="765"></canvas>
    </div>
</main>

<aside class="sidebar right">
    <div class="control-section">
        <div class="section-title" onclick="toggleSection(this)">
            <span>âš™ï¸ í™˜ê²½ ì„¤ì •</span>
            <span class="toggle-arrow">â–¼</span>
        </div>
        <div class="section-content">
            <label style="cursor:pointer; font-size: 14px; font-weight: bold; color: #007bff;">
                <input type="checkbox" id="mobile-mode-toggle"> ëª¨ë°”ì¼ ìµœì í™” UI ëª¨ë“œ
            </label>
        </div>
    </div>

    <div class="control-section">
        <div class="section-title" onclick="toggleSection(this)">
            <span>ğŸ”¤ í°íŠ¸ ì„¤ì •</span>
            <span class="toggle-arrow">â–¼</span>
        </div>
        <div class="section-content">
            <button class="font-btn" onclick="document.getElementById('font-input').click();">í°íŠ¸ ë³€ê²½</button>
            <input type="file" id="font-input" accept=".ttf, .otf, .woff, .woff2" style="display:none" onclick="this.value=null">
            
            <div id="manual-font-controls" style="margin-top: 10px;">
                <div class="slider-item">
                    <div class="label-with-reset">ì¢Œìƒë‹¨ <button class="reset-mini-btn" onclick="resetInputValue('text_tl', 41, true)">â†º</button></div>
                    <input type="range" class="font-slider" data-id="text_tl" min="10" max="150" value="41">
                    <input type="number" class="num-input font-num" data-id="text_tl" value="41">
                </div>
                <div class="slider-item">
                    <div class="label-with-reset">ì¢Œí•˜ë‹¨ <button class="reset-mini-btn" onclick="resetInputValue('text_bl', 24, true)">â†º</button></div>
                    <input type="range" class="font-slider" data-id="text_bl" min="10" max="150" value="24">
                    <input type="number" class="num-input font-num" data-id="text_bl" value="24">
                </div>
                <div class="slider-item">
                    <div class="label-with-reset">ìš°ìƒë‹¨ <button class="reset-mini-btn" onclick="resetInputValue('text_tr', 44, true)">â†º</button></div>
                    <input type="range" class="font-slider" data-id="text_tr" min="10" max="150" value="44">
                    <input type="number" class="num-input font-num" data-id="text_tr" value="44">
                </div>
            </div>
        </div>
    </div>

    <div class="control-section">
        <div class="section-title" onclick="toggleSection(this)">
            <span>âœ¨ íš¨ê³¼ ì„¤ì •</span>
            <span class="toggle-arrow">â–¼</span>
        </div>
        <div class="section-content">
            <div style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="cursor:pointer; font-size: 14px; display: flex; align-items: center;">
                    <input type="checkbox" id="logo-shadow-toggle" style="margin-right: 5px;"> ë¡œê³  ê·¸ë¦¼ì ì„¤ì •
                </label>
                <button class="reset-mini-btn" onclick="resetShadow()">â†º</button>
            </div>
            <div id="logo-shadow-controls" style="display: none; margin-top: 10px; font-size: 13px;">
                <div class="slider-item">ë¸”ëŸ¬: <input type="range" id="logo-shadow-blur" min="0" max="50" value="10"></div>
                <div class="slider-item">Xì¶•: <input type="range" id="logo-shadow-offsetx" min="-50" max="50" value="5"></div>
                <div class="slider-item">Yì¶•: <input type="range" id="logo-shadow-offsety" min="-50" max="50" value="5"></div>
                <div class="slider-item">ìƒ‰ìƒ: <input type="color" id="logo-shadow-color" value="#000000"></div>
            </div>

            <div style="display: flex; align-items: center; margin-top: 10px;">
                <label style="cursor:pointer; font-size: 14px; display: flex; align-items: center;">
                    <input type="checkbox" id="logo-border-toggle" style="margin-right: 5px;"> ë¡œê³  í…Œë‘ë¦¬ ì„¤ì •
                </label>
                <button class="reset-mini-btn" onclick="resetBorder()">â†º</button>
            </div>
            <div id="logo-border-controls" style="display: none; margin-top: 10px; font-size: 13px;">
                <div class="slider-item">
                    ë‘ê»˜: 
                    <input type="range" id="logo-border-width" min="0" step="0.01" max="15" value="2.5">
                    <input type="number" id="logo-border-num" class="num-input" value="2.5" step="0.01">
                </div>
                <div class="slider-item">
                    ìƒ‰ìƒ: <input type="color" id="logo-border-color" value="#000000">
                </div>
            </div>
        </div>
    </div>

    <div class="control-section">
        <div class="section-title" onclick="toggleSection(this)">
            <span>ğŸ’¾ ì €ì¥ ì˜µì…˜</span>
            <span class="toggle-arrow">â–¼</span>
        </div>
        <div class="section-content">
            <div class="slider-item">
                <div class="label-with-reset">ë°°ì†(ì›€ì§¤) <button class="reset-mini-btn" onclick="resetPlainInput('gif-speed-input', 1.0)">â†º</button></div>
                <input type="number" id="gif-speed-input" class="num-input" value="1.0" step="0.1" min="0.1">
            </div>
            <div class="slider-item">
                <div class="label-with-reset">FPS(ì›€ì§¤) <button class="reset-mini-btn" onclick="resetPlainInput('gif-fps-input', 0)">â†º</button></div>
                <input type="number" id="gif-fps-input" class="num-input" value="0">
            </div>
            <div class="slider-item">
                <div class="label-with-reset">ì§€ì—°(ì›€ì§¤) <button class="reset-mini-btn" onclick="resetPlainInput('gif-delay-input', 0)">â†º</button></div>
                <input type="number" id="gif-delay-input" class="num-input" value="0">
            </div>
            <div class="slider-item">
                <div class="label-with-reset">ë°°ìœ¨ <button class="reset-mini-btn" onclick="resetPlainInput('res-scale-input', '1.0')">â†º</button></div>
                <select id="res-scale-input" class="num-input" style="width: 70px;">
                    <option value="0.5">0.5x</option>
                    <option value="0.75">0.75x</option>
                    <option value="1.0" selected>1.0x</option>
                    <option value="1.5">1.5x</option>
                    <option value="2.0">2.0x</option>
                </select>
            </div>
            <div class="slider-item">
                <div class="label-with-reset">í’ˆì§ˆ(ì›€ì§¤) <button class="reset-mini-btn" onclick="resetPlainInput('gif-quality-input', 10)">â†º</button></div>
                <input type="number" id="gif-quality-input" class="num-input" value="10" min="1" max="20">
            </div>
        </div>
    </div>

    <div style="margin-top: auto;">
        <button class="upload-btn" style="background: #495057; margin-bottom: 5px;" onclick="window.open('https://Rukara12.github.io/Tenka-ZZANG-Template/old/old.html', '_blank');">êµ¬ë²„ì „ ì—ë””í„° ë°”ë¡œê°€ê¸°</button>
        <button class="issue-btn" onclick="window.open('https://github.com/Rukara12/Tenka-ZZANG-Template/tree/main', '_blank');">ì´ìŠˆ ë³´ê³ </button>
        <div style="display: flex; gap: 5px; margin-bottom: 5px;">
            <button class="history-btn" onclick="undo()">ë˜ëŒë¦¬ê¸° (Ctrl+Z)</button>
            <button class="history-btn" onclick="redo()">ë‹¤ì‹œí•˜ê¸° (Ctrl+Y)</button>
        </div>
        <button class="save-btn" id="save-btn">ìµœì¢… ê²°ê³¼ë¬¼ ì €ì¥ (GIF/PNG)</button>
    </div>
</aside>

<script src="https://unpkg.com/fabric@5.3.0/dist/fabric.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/buzzfeed/libgif-js@master/libgif.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>

<script>
    const canvas = new fabric.Canvas('c', {
        preserveObjectStacking: true,
        selection: false,
        allowTouchScrolling: false
    });

    const Z_INDEX = { PLACEHOLDER: 0, USER_IMG: 10, OVERLAY: 20, LOGO: 30, TEXT: 40 };
    
    const layers = {
        img1: null, img2: null, img3: null, overlay: null,
        text_tl: null, text_bl: null, text_tr: null, placeholders: []
    };

    const clipRects = {
        img1: { left: 200, top: 0, width: 700, height: 440 },
        img2: { left: 531, top: 470, width: 90, height: 150 },
        img3: { left: 635, top: 415, width: 380, height: 340 }
    };

    let activeGifs = [];

    document.fonts.ready.then(() => { initCanvas(); });

    // UI ì œì–´ í•¨ìˆ˜
    function toggleSection(header) {
        const content = header.nextElementSibling;
        const arrow = header.querySelector('.toggle-arrow');
        content.classList.toggle('collapsed');
        if (content.classList.contains('collapsed')) {
            arrow.style.transform = 'rotate(-90deg)';
        } else {
            arrow.style.transform = 'rotate(0deg)';
        }
    }

    function resetInputValue(id, val, isFont = false) {
        const sliders = document.querySelectorAll(`.font-slider[data-id="${id}"]`);
        const nums = document.querySelectorAll(`.num-input[data-id="${id}"]`);
        sliders.forEach(s => s.value = val);
        nums.forEach(n => n.value = val);
        if (isFont && layers[id]) {
            layers[id].set('fontSize', val);
            alignVerticalCenter(layers[id]);
            canvas.requestRenderAll();
            saveHistory();
        }
    }

    function resetPlainInput(id, val) {
        document.getElementById(id).value = val;
    }

    function resetShadow() {
        document.getElementById('logo-shadow-blur').value = 10;
        document.getElementById('logo-shadow-offsetx').value = 5;
        document.getElementById('logo-shadow-offsety').value = 5;
        document.getElementById('logo-shadow-color').value = "#000000";
        updateLogoEffects();
    }

    function resetBorder() {
        document.getElementById('logo-border-width').value = 2.5;
        document.getElementById('logo-border-num').value = 2.5;
        document.getElementById('logo-border-color').value = "#000000";
        updateLogoEffects();
    }

    function initCanvas() {
        createPlaceholders();
        const bgImg = new Image();
        bgImg.src = 'tenka.png';
        bgImg.onload = function() {
            const img = new fabric.Image(bgImg, { left: 0, top: 0, selectable: false, evented: false });
            img._layerKey = 'overlay';
            layers.overlay = img;
            canvas.add(img);
            initTextLayers();
            reorderLayers();
            saveHistory();
        };
        canvas.on('object:modified', saveHistory);
    }

    function createPlaceholders() {
        const createRect = (l, t, w, h, txt) => {
            const rect = new fabric.Rect({
                left: l, top: t, width: w, height: h,
                fill: '#f8f9fa', stroke: '#ced4da', strokeWidth: 2, strokeDashArray: [5, 5],
                selectable: false, evented: false
            });
            const text = new fabric.Text(txt, {
                left: l + w/2, top: t + h/2, originX: 'center', originY: 'center',
                fontSize: 16, fill: '#adb5bd', fontFamily: 'PyeongtaekSunset', selectable: false, evented: false
            });
            layers.placeholders.push({ rect, text });
            canvas.add(rect, text);
        };
        createRect(200, 0, 700, 440, "ë§í’ì„  ì‚¬ì§„ ì˜ì—­");
        createRect(531, 470, 90, 150, "í°");
        createRect(635, 415, 380, 340, "ë¡œê³  ì˜ì—­");
    }

    function initTextLayers() {
        const commonStyle = {
            fontFamily: 'PyeongtaekSunset', fontWeight: 'bold', textAlign: 'center',
            fill: '#000000', lineHeight: 1.2, originX: 'left', originY: 'top',
            editable: true, splitByGrapheme: false, padding: 15
        };

        const createText = (text, l, t, w, h, key, defaultSize) => {
            const tBox = new fabric.Textbox(text, {
                ...commonStyle, left: l, top: t, width: w, height: h, fixedHeight: h, fontSize: defaultSize
            });
            tBox._layerKey = key;
            tBox._originalTop = t;
            layers[key] = tBox;
            canvas.add(tBox);
            
            tBox.on('scaling', function() {
                const scaleX = this.scaleX;
                const newFontSize = this.fontSize * scaleX;
                this.set({ fontSize: newFontSize, width: this.width * scaleX, scaleX: 1, scaleY: 1 });
                syncFontControls(this);
            });

            tBox.on('changed', () => { alignVerticalCenter(tBox); saveHistory(); });
        };

        createText("í…ì¹´ì¨© ë°˜ë°•í•˜ëŠ” ë‚´ìš©Â·Â·Â·\në“£ê¸° ì‹«ì€ ë§Â·Â·Â·", 1, 1, 215, 330, 'text_tl', 41);
        createText("ë‚˜ì¨© ë¯¸ì•ˆÂ·Â·Â· ì˜ ì•ˆ ë“¤ë ¤Â·Â·Â·\nì•„ë¬´íŠ¼ ì–´ì©Œêµ¬ ì €ì©Œêµ¬ í•œë°ë‹¤\nì´ëŸ¬ì €ëŸ¬í•˜ê³  ì´ë˜ì €ë˜\nì¥ì ì´ ë§ì•„ì„œ ì¬ë°ŒëŠ” ê²Œì„ì´ë¼ëŠ”\nì¥í™©í•œ ì„¤ëª…Â·Â·Â·", 1, 420, 230, 350, 'text_bl', 24);
        createText("ë‚˜ì¨© ì´ê±° ë´ë´Â·Â·Â·!\nëŒ€ì¶© ì–´ì©Œêµ¬ ì €ì©Œêµ¬\nê°“ê²œÂ·Â·Â·!", 810, 1, 215, 410, 'text_tr', 44);

        Object.keys(layers).forEach(k => { if(k.startsWith('text')) alignVerticalCenter(layers[k]); });
    }

    function alignVerticalCenter(textbox) {
        if (!textbox || !textbox.fixedHeight) return;
        const textHeight = textbox.calcTextHeight();
        const boxHeight = textbox.fixedHeight;
        const originalTop = textbox._originalTop || textbox.top;
        if (textHeight < boxHeight) { textbox.set('top', originalTop + (boxHeight - textHeight) / 2); } 
        else { textbox.set('top', originalTop); }
        canvas.requestRenderAll();
    }

    function reorderLayers() {
        layers.placeholders.forEach(p => { p.rect.sendToBack(); p.text.sendToBack(); });
        if (layers.img1) layers.img1.moveTo(Z_INDEX.USER_IMG);
        if (layers.img2) layers.img2.moveTo(Z_INDEX.USER_IMG + 1);
        if (layers.overlay) layers.overlay.moveTo(Z_INDEX.OVERLAY);
        if (layers.img3) layers.img3.moveTo(Z_INDEX.LOGO);
        if (layers.text_tl) layers.text_tl.bringToFront();
        if (layers.text_bl) layers.text_bl.bringToFront();
        if (layers.text_tr) layers.text_tr.bringToFront();
        canvas.requestRenderAll();
    }

    function updateGifInfo() {
        let infoStr = "ì¸¡ì •ëœ FPS:<br>";
        if (activeGifs.length === 0) {
            infoStr = "ì¸¡ì •ëœ FPS: -";
        } else {
            activeGifs.forEach((g) => {
                let d = 100;
                try { d = g.superGif.get_frames()[0].delay * 10; } catch(e) {}
                let fps = (1000 / d).toFixed(1);
                let name = g.fabricObj._layerKey === 'img1' ? 'ë§í’ì„ ' : (g.fabricObj._layerKey === 'img2' ? 'í•¸ë“œí°' : 'ë¡œê³ ');
                infoStr += `[${name}] ${fps} FPS<br>`;
            });
        }
        document.getElementById('detected-fps-info').innerHTML = infoStr;
    }

    function cleanupLayer(layerKey) {
        if (!layers[layerKey]) return;
        canvas.remove(layers[layerKey]);
        const gifIdx = activeGifs.findIndex(g => g.fabricObj === layers[layerKey]);
        if (gifIdx > -1) {
            const gifData = activeGifs[gifIdx];
            if (gifData.superGif) gifData.superGif.pause();
            if (gifData.container && gifData.container.parentNode) {
                gifData.container.parentNode.removeChild(gifData.container);
            }
            activeGifs.splice(gifIdx, 1);
        }
        layers[layerKey] = null;
        updateGifInfo();
    }

    function handleImageUpload(file, layerKey) {
        if (!file) return;
        cleanupLayer(layerKey);
        const reader = new FileReader();
        reader.onload = function(e) {
            const result = e.target.result;
            if (file.type === 'image/gif') { loadGif(result, layerKey); } 
            else { fabric.Image.fromURL(result, function(img) { setupLayerObj(img, layerKey); }); }
        };
        reader.readAsDataURL(file);
    }

    function loadGif(dataUrl, layerKey) {
        const container = document.createElement('div');
        container.style.position = 'fixed'; container.style.left = '-9999px';
        container.style.top = '-9999px'; container.style.visibility = 'hidden';
        container.style.width = '0px'; container.style.height = '0px';
        container.style.overflow = 'hidden';
        document.body.appendChild(container);

        const imgTag = document.createElement('img');
        imgTag.src = dataUrl;
        container.appendChild(imgTag);

        const rubbableGif = new SuperGif({ gif: imgTag, auto_play: false });
        rubbableGif.load(function() {
            const gifCanvas = rubbableGif.get_canvas();
            const fabricImg = new fabric.Image(gifCanvas, { objectCaching: false });
            fabricImg._gifDataUrl = dataUrl; 
            setupLayerObj(fabricImg, layerKey);
            activeGifs.push({ fabricObj: fabricImg, superGif: rubbableGif, canvasEl: gifCanvas, container: container });
            rubbableGif.play();
            updateGifInfo();
        });
    }

    function setupLayerObj(obj, layerKey) {
        let def = { left: 0, top: 0 };
        if (clipRects[layerKey]) {
            def = { left: clipRects[layerKey].left + clipRects[layerKey].width / 2, top: clipRects[layerKey].top + clipRects[layerKey].height / 2 };
            obj.set({ originX: 'center', originY: 'center', left: def.left, top: def.top });
            obj.clipPath = new fabric.Rect({ left: clipRects[layerKey].left, top: clipRects[layerKey].top, width: clipRects[layerKey].width, height: clipRects[layerKey].height, absolutePositioned: true });
        }
        if (obj.width > 500 && layerKey !== 'img1') obj.scaleToWidth(300);
        obj._layerKey = layerKey;
        obj._originalState = { left: def.left, top: def.top, scaleX: obj.scaleX, scaleY: obj.scaleY, angle: 0, flipX: false };
        layers[layerKey] = obj;
        canvas.add(obj);
        canvas.setActiveObject(obj);
        reorderLayers();
        saveHistory();
    }

    function renderLoop() {
        if (activeGifs.length > 0) {
            let dirty = false;
            activeGifs.forEach(g => { if (g.superGif.get_playing()) { g.fabricObj.dirty = true; dirty = true; } });
            if (dirty) canvas.requestRenderAll();
        }
        requestAnimationFrame(renderLoop);
    }
    requestAnimationFrame(renderLoop);

    document.querySelectorAll('input[name="target"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            const val = e.target.value;
            canvas.discardActiveObject();
            if (val !== 'none' && layers[val]) { canvas.setActiveObject(layers[val]); }
            canvas.requestRenderAll();
        });
    });

    canvas.on('selection:created', onSelectionChange);
    canvas.on('selection:updated', onSelectionChange);
    canvas.on('selection:cleared', () => {
        setFocusMode(null);
        document.querySelector('input[name="target"][value="none"]').checked = true;
    });

    function setFocusMode(activeObj) {
        if (!layers.overlay) return;
        const photoTargets = [layers.img1, layers.img2, layers.img3];
        const isPhotoSelected = photoTargets.includes(activeObj);
        if (isPhotoSelected && activeObj !== null) {
            layers.overlay.set('opacity', 0.3);
            ['text_tl', 'text_bl', 'text_tr'].forEach(k => { if(layers[k]) layers[k].set('opacity', 0); });
        } else {
            layers.overlay.set('opacity', 1.0);
            ['text_tl', 'text_bl', 'text_tr'].forEach(k => { if(layers[k]) layers[k].set('opacity', 1.0); });
        }
        canvas.requestRenderAll();
    }

    function resetAllOpacities() {
        if (layers.overlay) layers.overlay.set('opacity', 1.0);
        ['text_tl', 'text_bl', 'text_tr'].forEach(k => { if(layers[k]) layers[k].set('opacity', 1.0); });
        canvas.requestRenderAll();
    }

    window.resetActiveObject = () => {
        const obj = canvas.getActiveObject();
        if(obj && obj._originalState) {
            obj.set({ left: obj._originalState.left, top: obj._originalState.top, scaleX: obj._originalState.scaleX, scaleY: obj._originalState.scaleY, angle: 0, flipX: false });
            canvas.requestRenderAll();
            saveHistory();
        }
    };
    window.rotateActiveObject = () => {
        const obj = canvas.getActiveObject();
        if(obj) { obj.rotate((obj.angle + 90) % 360); canvas.requestRenderAll(); saveHistory(); }
    };
    window.flipActiveObject = () => {
        const obj = canvas.getActiveObject();
        if(obj) { obj.set('flipX', !obj.flipX); canvas.requestRenderAll(); saveHistory(); }
    };

    window.deleteActiveObject = () => {
        const obj = canvas.getActiveObject();
        if (obj && obj._layerKey && obj._layerKey.startsWith('img')) {
            cleanupLayer(obj._layerKey);
            saveHistory();
            canvas.requestRenderAll();
        }
    };

    function syncFontControls(textbox) {
        if (!textbox._layerKey) return;
        const id = textbox._layerKey;
        const val = Math.round(textbox.fontSize);
        const slider = document.querySelector(`.font-slider[data-id="${id}"]`);
        const num = document.querySelector(`.num-input[data-id="${id}"]`);
        if (slider) slider.value = val;
        if (num) num.value = val;
    }

    document.querySelectorAll('.font-slider, .font-num').forEach(el => {
        el.addEventListener('input', (e) => {
            const id = e.target.dataset.id;
            const val = parseInt(e.target.value);
            if (layers[id]) {
                layers[id].set('fontSize', val);
                document.querySelector(`.font-slider[data-id="${id}"]`).value = val;
                document.querySelector(`.num-input[data-id="${id}"]`).value = val;
                alignVerticalCenter(layers[id]);
                canvas.requestRenderAll();
                saveHistory();
            }
        });
    });

    function updateLogoEffects() {
        if (!layers.img3) return;
        const shadowOn = document.getElementById('logo-shadow-toggle').checked;
        const borderOn = document.getElementById('logo-border-toggle').checked;
        layers.img3.set({ stroke: null, strokeWidth: 0, shadow: null });
        if (!shadowOn && !borderOn) {
            delete layers.img3._render;
            canvas.requestRenderAll();
            return;
        }
        layers.img3._render = function(ctx) {
            const el = this._element;
            if (!el) return;
            ctx.save();
            const w = this.width; const h = this.height;
            if (borderOn) {
                const bWidth = parseFloat(document.getElementById('logo-border-width').value);
                const bColor = document.getElementById('logo-border-color').value;
                ctx.filter = `drop-shadow(${bWidth}px 0 0 ${bColor}) drop-shadow(-${bWidth}px 0 0 ${bColor}) drop-shadow(0 ${bWidth}px 0 ${bColor}) drop-shadow(0 -${bWidth}px 0 ${bColor})`;
            }
            if (shadowOn) {
                ctx.shadowColor = document.getElementById('logo-shadow-color').value;
                ctx.shadowBlur = parseInt(document.getElementById('logo-shadow-blur').value);
                ctx.shadowOffsetX = parseInt(document.getElementById('logo-shadow-offsetx').value);
                ctx.shadowOffsetY = parseInt(document.getElementById('logo-shadow-offsety').value);
            }
            ctx.drawImage(el, -w/2, -h/2, w, h);
            ctx.restore();
        };
        canvas.requestRenderAll();
        saveHistory();
    }
    
    document.getElementById('logo-shadow-toggle').addEventListener('change', (e) => {
        document.getElementById('logo-shadow-controls').style.display = e.target.checked ? 'block' : 'none';
        updateLogoEffects();
    });
    ['logo-shadow-blur', 'logo-shadow-offsetx', 'logo-shadow-offsety', 'logo-shadow-color'].forEach(id => {
        document.getElementById(id).addEventListener('input', updateLogoEffects);
    });
    document.getElementById('logo-border-toggle').addEventListener('change', (e) => {
        document.getElementById('logo-border-controls').style.display = e.target.checked ? 'block' : 'none';
        updateLogoEffects();
    });
    document.getElementById('logo-border-width').addEventListener('input', (e) => {
        document.getElementById('logo-border-num').value = e.target.value;
        updateLogoEffects();
    });
    document.getElementById('logo-border-color').addEventListener('input', updateLogoEffects);

    let stateHistory = [];
    let historyStep = -1;
    let isHistoryLocked = false;
    const SAVE_PROPS = ['editable', 'id', 'fixedHeight', 'selectable', 'evented', '_layerKey', '_originalState', 'padding', '_originalTop', '_gifDataUrl'];

    function saveHistory() {
        if (isHistoryLocked) return;
        const json = JSON.stringify(canvas.toJSON(SAVE_PROPS));
        if (historyStep < stateHistory.length - 1) stateHistory = stateHistory.slice(0, historyStep + 1);
        stateHistory.push(json);
        historyStep++;
        if(stateHistory.length > 20) { stateHistory.shift(); historyStep--; }
    }

    function undo() { 
        if (historyStep > 0) { 
            const activeObj = canvas.getActiveObject();
            if (activeObj && activeObj.isEditing) activeObj.exitEditing(); 
            historyStep--; 
            loadState(stateHistory[historyStep]); 
        } 
    }
    
    function redo() { 
        if (historyStep < stateHistory.length - 1) { 
            const activeObj = canvas.getActiveObject();
            if (activeObj && activeObj.isEditing) activeObj.exitEditing();
            historyStep++; 
            loadState(stateHistory[historyStep]); 
        } 
    }

    function loadState(json) {
        isHistoryLocked = true;
        canvas.discardActiveObject();

        activeGifs.forEach(g => {
            if (g.superGif) g.superGif.pause();
            if (g.container && g.container.parentNode) {
                g.container.parentNode.removeChild(g.container);
            }
        });
        activeGifs = [];

        canvas.loadFromJSON(json, () => {
            const objs = canvas.getObjects();
            layers.img1 = layers.img2 = layers.img3 = null;

            objs.forEach(obj => {
                if (obj._layerKey) {
                    layers[obj._layerKey] = obj;
                    if(clipRects[obj._layerKey]) {
                        obj.clipPath = new fabric.Rect({ 
                            left: clipRects[obj._layerKey].left, 
                            top: clipRects[obj._layerKey].top, 
                            width: clipRects[obj._layerKey].width, 
                            height: clipRects[obj._layerKey].height, 
                            absolutePositioned: true 
                        });
                    }
                }

                if (obj.type === 'textbox') {
                    obj.set({ editable: true, selectable: true });
                    obj.setCoords(); 
                    obj.on('changed', () => { alignVerticalCenter(obj); saveHistory(); });
                    obj.on('scaling', function() {
                        const scaleX = this.scaleX;
                        const newFontSize = this.fontSize * scaleX;
                        this.set({ fontSize: newFontSize, width: this.width * scaleX, scaleX: 1, scaleY: 1 });
                        syncFontControls(this);
                    });
                }

                if (obj._gifDataUrl) {
                    const container = document.createElement('div');
                    container.style.position = 'fixed'; container.style.left = '-9999px';
                    container.style.top = '-9999px'; container.style.visibility = 'hidden';
                    container.style.width = '0px'; container.style.height = '0px';
                    container.style.overflow = 'hidden';
                    document.body.appendChild(container);

                    const imgTag = document.createElement('img');
                    imgTag.src = obj._gifDataUrl;
                    container.appendChild(imgTag);

                    const rubbableGif = new SuperGif({ gif: imgTag, auto_play: false });
                    rubbableGif.load(function() {
                        const gifCanvas = rubbableGif.get_canvas();
                        obj.setElement(gifCanvas);
                        obj.set({ objectCaching: false, dirty: true });
                        activeGifs.push({ fabricObj: obj, superGif: rubbableGif, canvasEl: gifCanvas, container: container });
                        rubbableGif.play();
                        updateGifInfo();
                    });
                }
            });

            if (layers.img3) updateLogoEffects();

            reorderLayers();
            isHistoryLocked = false;
            canvas.requestRenderAll();
            updateGifInfo();
        });
    }

    const gifWorkerBlob = new Blob([`importScripts('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');`], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(gifWorkerBlob);

    document.getElementById('save-btn').addEventListener('click', async () => {
        canvas.discardActiveObject();
        resetAllOpacities();

        const now = new Date();
        const dateStr = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}`;
        const resScale = parseFloat(document.getElementById('res-scale-input').value);
        const gifQuality = parseInt(document.getElementById('gif-quality-input').value);

        const wrapper = document.getElementById('canvas-wrapper');
        const originalTransform = wrapper.style.transform;
        const originalMargin = wrapper.style.marginTop;
        wrapper.style.transform = 'none'; wrapper.style.marginTop = '0';
        
        const loading = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        loading.style.display = 'flex';

        if (activeGifs.length === 0) {
            setTimeout(() => {
                const dataURL = canvas.toDataURL({ format: 'png', multiplier: resScale });
                const link = document.createElement('a');
                link.download = `í…ì¹´_ê²°ê³¼ë¬¼_${dateStr}.png`;
                link.href = dataURL; link.click();
                wrapper.style.transform = originalTransform; wrapper.style.marginTop = originalMargin;
                loading.style.display = 'none';
            }, 100);
            return;
        }

        let speedMult = parseFloat(document.getElementById('gif-speed-input').value) || 1.0;
        let userFps = parseFloat(document.getElementById('gif-fps-input').value);
        let userFrameDelay = parseInt(document.getElementById('gif-delay-input').value);

        loadingText.innerText = "í”„ë ˆì„ ì¶”ì¶œ ì¤‘...";
        let mainGif = activeGifs[0];
        let calculatedMaxFrames = 0;
        let originalDelay = 100;
        activeGifs.forEach(g => {
            const len = g.superGif.get_length();
            if (len > calculatedMaxFrames) { calculatedMaxFrames = len; mainGif = g; }
        });
        try {
            const frames = mainGif.superGif.get_frames(); 
            if(frames && frames.length > 0 && frames[0].delay) originalDelay = frames[0].delay * 10;
        } catch(e) {}
        let finalDelay = originalDelay / speedMult;
        if (userFps > 0) finalDelay = 1000 / userFps;
        else if (userFrameDelay > 0) finalDelay = userFrameDelay;

        const totalDuration = (calculatedMaxFrames * originalDelay) / speedMult;
        const maxFrames = Math.max(1, Math.round(totalDuration / finalDelay));

        const gif = new GIF({ 
            workers: 4, quality: gifQuality, 
            width: 1024 * resScale, height: 765 * resScale, 
            workerScript: workerUrl 
        });
        activeGifs.forEach(g => g.superGif.pause());

        for (let i = 0; i < maxFrames; i++) {
            loadingText.innerText = `í”„ë ˆì„ ìº¡ì²˜ (${i + 1}/${maxFrames})`;
            activeGifs.forEach(g => {
                const len = g.superGif.get_length();
                const progress = i / maxFrames;
                const targetFrame = Math.floor(progress * len);
                g.superGif.move_to(targetFrame % len);
                g.fabricObj.dirty = true;
            });
            const frameCanvas = canvas.toCanvasElement(resScale);
            gif.addFrame(frameCanvas, { delay: finalDelay, copy: true });
            await new Promise(r => setTimeout(r, 0));
        }
        
        loadingText.innerText = "ì¸ì½”ë”© ì¤‘...";
        gif.on('finished', function(blob) {
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `í…ì¹´_ì›€ì§¤_${dateStr}.gif`;
            link.click();
            activeGifs.forEach(g => g.superGif.play());
            wrapper.style.transform = originalTransform; wrapper.style.marginTop = originalMargin;
            loading.style.display = 'none';
        });
        gif.render();
    });

    document.getElementById('mobile-mode-toggle').addEventListener('change', (e) => {
        const wrapper = document.getElementById('canvas-wrapper');
        if (e.target.checked) {
            document.body.classList.add('mobile-mode');
            const winWidth = window.innerWidth;
            const scale = Math.min((winWidth - 40) / 1024, 1);
            wrapper.style.transform = `scale(${scale})`;
            wrapper.style.marginTop = '0px';
        } else {
            document.body.classList.remove('mobile-mode');
            wrapper.style.transform = 'scale(1)';
            wrapper.style.marginTop = '0';
        }
    });

    window.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); }
        if (e.key === 'Delete') { deleteActiveObject(); }
    });
    
    document.getElementById('font-input').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (ev) => {
            const fontFace = new FontFace('CustomFont', ev.target.result);
            await fontFace.load();
            document.fonts.add(fontFace);
            ['text_tl', 'text_bl', 'text_tr'].forEach(k => { if(layers[k]) layers[k].set('fontFamily', 'CustomFont'); });
            canvas.requestRenderAll();
            alert('ìƒˆë¡œìš´ í°íŠ¸ê°€ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.');
        };
        reader.readAsArrayBuffer(file);
    });

    document.getElementById('sgdb-search-btn').addEventListener('click', function() {
        const term = document.getElementById('sgdb-input').value.trim();
        if (term) window.open(`https://www.steamgriddb.com/search/grids?term=${encodeURIComponent(term)}`, '_blank');
    });

    document.getElementById('img-input-1').addEventListener('change', (e) => handleImageUpload(e.target.files[0], 'img1'));
    document.getElementById('img-input-2').addEventListener('change', (e) => handleImageUpload(e.target.files[0], 'img2'));
    document.getElementById('img-input-3').addEventListener('change', (e) => handleImageUpload(e.target.files[0], 'img3'));

    // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì´ë²¤íŠ¸ ì²˜ë¦¬ ìˆ˜ì •
    const dropZone = document.getElementById('drop-zone');
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropZone.style.backgroundColor = '#adb5bd';
    });

    dropZone.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropZone.style.backgroundColor = '#ced4da';
    });

    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropZone.style.backgroundColor = '#ced4da';

        const files = e.dataTransfer.files;
        if (files && files.length > 0) {
            const selectedTarget = document.querySelector('input[name="target"]:checked').value;
            let targetLayer = selectedTarget;

            // ì„ íƒëœ ë ˆì´ì–´ê°€ ì—†ê±°ë‚˜ ì´ë¯¸ì§€ ë ˆì´ì–´ê°€ ì•„ë‹ ë•Œ ë§ˆìš°ìŠ¤ ì¢Œí‘œ ê¸°ì¤€ ê°ì§€
            if (selectedTarget === 'none' || !selectedTarget.startsWith('img')) {
                const pointer = canvas.getPointer(e);
                const x = pointer.x;
                const y = pointer.y;

                // ê¸°ë³¸ ë ˆì´ì–´ëŠ” img1ë¡œ ì„¤ì •í•˜ë˜, ê° í´ë¦¬í•‘ ì˜ì—­ ì•ˆì— ë§ˆìš°ìŠ¤ê°€ ìˆë‹¤ë©´ í•´ë‹¹ ë ˆì´ì–´ë¡œ ë³€ê²½
                targetLayer = 'img1'; 
                for (const [key, rect] of Object.entries(clipRects)) {
                    if (x >= rect.left && x <= rect.left + rect.width &&
                        y >= rect.top && y <= rect.top + rect.height) {
                        targetLayer = key;
                        break;
                    }
                }
            }
            handleImageUpload(files[0], targetLayer);
        }
    });

    function onSelectionChange(e) {
        const obj = e.selected[0];
        setFocusMode(obj);
        let val = 'none';
        if (obj === layers.img1) val = 'img1';
        else if (obj === layers.img2) val = 'img2';
        else if (obj === layers.img3) val = 'img3';
        const radio = document.querySelector(`input[name="target"][value="${val}"]`);
        if (radio) radio.checked = true;
    }
</script>
</body>
</html>
